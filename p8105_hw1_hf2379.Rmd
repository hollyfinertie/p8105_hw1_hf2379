---
title: "Homework # 1"
author: "Holly Finertie (HF2379), Due:"
date: 2019-09-20
output: github_document
---

```{r setup, include=FALSE}
library(tidyverse)
```

# Problem1

## Create a dataframe:

```{r problem1_dataframe}
prob1_df = tibble (
  prob1_sample = rnorm(8, mean=0, sd = 1),
  prob1_logic_vec = prob1_sample > 0,
  prob1_char_vec = c("I","Am", "A", "Little", "Confused", "Is", "This", "Right"),
  prob1_factor_vec = factor(c("yes", "no", "maybe", "yes", "no", "maybe", "yes", "no"))
)
```

## Try to take the mean of each variable:

* **The mean of the sample size is `r mean(pull(prob1_df, prob1_sample))`**. We are able to take the mean because the sample size is a numeric data type. 

* **The mean of the logical statement is `r mean(pull(prob1_df, prob1_logic_vec))`**. We are able to take the mean of the logical statement because it is a Boolean data type (TRUE=1 and FALSE=0). Even if the output is displayed as TRUE/FALSE, the values of 1 and 0 are in the background. 

* **The mean of the character vector is `r mean(pull(prob1_df, prob1_char_vec))`**. We are not able to take the mean of the character vector because it is text/character data type that does not correspond with numeric values. The error states that we can only take the mean of a numeric or logical argument.

* **The mean of the factor vector is `r mean(pull(prob1_df, prob1_factor_vec))`**. We are unable to take the mean of the factor vector because it is a text/character data type that does not correspond with numeric values. The error states that we can only take the mean of a numeric or logical argument.


## First Code Chunk: Convert to numeric


```{r problem1_convert, eval = FALSE}
as.numeric(pull(prob1_df, prob1_logic_vec))
as.numeric(pull(prob1_df, prob1_char_vec))
as.numeric(pull(prob1_df, prob1_factor_vec))
```

The as.numeric function works on the logic and factor vectors, but not the character vector. We already knew that we were able to take the mean of a Boolean data type (logic vector); however, it is surprising that the as.numeric function works on the factor vector when we were unable to take the mean. Becuase there were 3 levels, the as.numeric function converted the different levels to 1, 2, and 3. Last, and unsurprisingly, the as.numeric function did not work on the character vector. There is not logical way to convert random words without a pattern into numbers. 

## Second Code Chunk: Convert and multiply

```{r problem1_secondchunk}
as.numeric(pull(prob1_df, prob1_logic_vec))*pull(prob1_df, prob1_sample)
as.factor(pull(prob1_df, prob1_logic_vec))*pull(prob1_df, prob1_sample)
as.numeric(as.factor(pull(prob1_df, prob1_logic_vec)))*pull(prob1_df, prob1_sample)
```

As seen above, we were able to convert the logical vector into a numeric value and multiply by the random sample.The other two commands had more surprising results. We learned that converting the logical vector to a factor vector resulted in a vector that was unable to be multiplied by the random sample. Then, we were able to convert a logical vector into a factor vector and then into a numeric vector, which was able to be multiplied. Both these results align with our previous attempts to do math with different data types: (1) we tried to take the mean of a factor and that didnt' work and (2) we convereted a factor vector into a numeric vector and were able to take the mean. 

# Problem 2

```{r problem2_dataframe}
prob2_df = tibble(
  x = rnorm(500, mean = 0, sd = 1),
  y = rnorm(500, mean = 0, sd = 1),
  prob2_logic_vec = (x + y) > 1,
  prob2_num_vec = as.numeric(prob2_logic_vec),
  prob2_factor_vec = as.factor(prob2_logic_vec)
)
```

## Describing the newly created data frame

* This dataset contains `r nrow(prob2_df)` rows and `r ncol(prob2_df)` columns

* The mean of x is `r mean(pull(prob2_df, x))` 

* The median of x is `r median(pull(prob2_df, x))`

* The standard deviation of x is `r sd(pull(prob2_df, x))`

* The proportion of cases for which x + y > 1 is `r mean(pull(prob2_df, prob2_num_vec))`

## Plots for Problem 2

```{r problem2_plot_logical}
plot1 = ggplot(prob2_df, aes(x = x, y = y, color = prob2_logic_vec)) + geom_point()
plot1
```

* This plot has two colors, red and blue, because we set the colors to equal the logical vector which was two outcomes: FALSE and TRUE. 


```{r problem2_plot_nvector}
plot2 = ggplot(prob2_df, aes(x = x, y = y, color = prob2_num_vec)) + geom_point()
plot2
```


* This plot's colors range from light blue (1.0) to dark blue (0.0) because we set the color equal to the numeric vector which was outcomes 0 and 1. This numeric vector was created from the logical vector (TRUE=1 and FALSE=0). While the color legend provides a range of colors from 0-1, the output only shows dots that correspond to 0 and 1 identical to plot 1 above. 


```{r problem2_plot_fvector}
plot3 = ggplot(prob2_df, aes(x = x, y = y, color = prob2_factor_vec)) + geom_point()
plot3
```


* This plot has two colors, red and blue, because we set the colors equal to the factor vector which was two outcomes: FALSE and TRUE. This factor vector was created from the logical vector and therefore the graph is identical to plot 1. 


## Saving my scatterplots

```{r}
ggsave(plot1, file = "plot1.png")
ggsave(plot2, file = "plot2.png")
ggsave(plot3, file = "plot3.png")
```

Done with HW 1! 


