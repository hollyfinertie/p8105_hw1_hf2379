---
title: "Homework # 1"
author: "Holly Finertie (HF2379), Due:"
date: 2019-09-20
output: github_document
---

```{r setup, include=FALSE}
library(tidyverse)
```

# Problem1

## Create a dataframe:

```{r problem1_dataframe}
prob1_df = tibble (
  prob1_sample = rnorm(8, mean=0, sd = 1),
  prob1_sample_over0 = prob1_sample > 0,
  prob1_char = c("I","Am", "A", "Little", "Confused", "Is", "This", "Right"),
  prob1_factor = factor(c("yes", "no", "maybe", "yes", "no", "maybe", "yes", "no"))
)
```

## Try to take the mean of each variable:

* The mean of the sample size is `r mean(pull(prob1_df, prob1_sample))`.

* The mean of the logical statement is `r mean(pull(prob1_df, prob1_sample_over0))`.

* The mean of the character vector is `r mean(pull(prob1_df, prob1_char))`.

* The mean of the factor vector is `r mean(pull(prob1_df, prob1_factor))`.

We were able to take the mean of the first two variables because they are numeric. However, we could not take the mean of the character or factor vector because they were text and not numeric. 

## Convert Code Chunk to Numeric


```{r problem1_convert, eval = FALSE}
as.numeric(pull(prob1_df, prob1_sample_over0))
as.numeric(pull(prob1_df, prob1_char))
as.numeric(pull(prob1_df, prob1_factor))
```

I was able to convert the logical statement and factor vector to numeric, but not the character vector. This does not completely explain why I was unable to take the mean of the

## Second Code Chunk

```{r problem1_secondchunk}
as.numeric(pull(prob1_df, prob1_sample_over0))*pull(prob1_df, prob1_sample)
as.factor(pull(prob1_df, prob1_sample_over0))*pull(prob1_df, prob1_sample)
as.numeric(as.factor(pull(prob1_df, prob1_sample_over0)))*pull(prob1_df, prob1_sample)
```

# Problem 2

```{r problem2_dataframe}
prob2_df = tibble(
  x = rnorm(500, mean = 0, sd = 1),
  y = rnorm(500, mean = 0, sd = 1),
  prob2_logical = (x + y) > 1,
  prob2_nvector = as.numeric(prob2_logical),
  prob2_fvector = as.factor(prob2_logical)
)
```

## Describing the newly created data frame

* This dataset contains `r nrow(prob2_df)` rows and `r ncol(prob2_df)` columns

* the mean of x is `r mean(pull(prob2_df, x))` 

* the median of x is `r median(pull(prob2_df, x))`

* the standard deviation of x is `r sd(pull(prob2_df, x))`

* the proportion of cases for which x + y > 1 is `r mean(pull(prob2_df, prob2_nvector))`

## Plots for Problem 2

```{r problem2_plot_logical}
plot1 = ggplot(prob2_df, aes(x = x, y = y, color = prob2_logical)) + geom_point()
plot1
```
* This plot has two colors, red and blue, for FALSE and TRUE, respectively. That's because the color assignments are based on the values for our logical vector which is either TRUE or FALSE.

```{r problem2_plot_nvector}
plot2 = ggplot(prob2_df, aes(x = x, y = y, color = prob2_nvector)) + geom_point()
plot2
```

* This plot has a range of colors for our range of values between 1 and 0. This color is numeric and therefore has a range of values. But since this was built off of our logical vector (TRUE, FALSE), we only see values for 1 and 0 .

```{r problem2_plot_fvector}
plot3 = ggplot(prob2_df, aes(x = x, y = y, color = prob2_fvector)) + geom_point()
plot3
```

* This plot has two colors, red and blue, for FALSE and TRUE, respectively. That's because the color assignments are based on the values for our factor vector which are either TRUE or FALSE.

## Saving my scatterplots

```{r}
ggsave(plot1, file = "plot1.png")
ggsave(plot2, file = "plot2.png")
ggsave(plot3, file = "plot3.png")
```

## Done with HW 1! 


