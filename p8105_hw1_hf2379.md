Homework \# 1
================
Holly Finertie (HF2379), Due:
2019-09-20

# Problem1

## Create a dataframe:

``` r
prob1_df = tibble (
  prob1_sample = rnorm(8, mean=0, sd = 1),
  prob1_logic_vec = prob1_sample > 0,
  prob1_char_vec = c("I","Am", "A", "Little", "Confused", "Is", "This", "Right"),
  prob1_factor_vec = factor(c("yes", "no", "maybe", "yes", "no", "maybe", "yes", "no"))
)
```

## Try to take the mean of each variable:

  - **The mean of the sample size is -0.1242432**. We are able to take
    the mean because the sample size is a numeric data type.

  - **The mean of the logical statement is 0.25**. We are able to take
    the mean of the logical statement because it is a Boolean data type
    (TRUE=1 and FALSE=0). Even if the output is displayed as TRUE/FALSE,
    the values of 1 and 0 are in the background.

  - **The mean of the character vector is NA**. We are not able to take
    the mean of the character vector because it is text/character data
    type that does not correspond with numeric values. The error states
    that we can only take the mean of a numeric or logical argument.

  - **The mean of the factor vector is NA**. We are unable to take the
    mean of the factor vector because it is a text/character data type
    that does not correspond with numeric values. The error states that
    we can only take the mean of a numeric or logical argument.

## First Code Chunk: Convert to numeric

``` r
as.numeric(pull(prob1_df, prob1_logic_vec))
as.numeric(pull(prob1_df, prob1_char_vec))
as.numeric(pull(prob1_df, prob1_factor_vec))
```

The as.numeric function works on the logic and factor vectors, but not
the character vector. We already knew that we were able to take the mean
of a Boolean data type (logic vector); however, it is surprising that
the as.numeric function works on the factor vector when we were unable
to take the mean. Becuase there were 3 levels, the as.numeric function
converted the different levels to 1, 2, and 3. Last, and unsurprisingly,
the as.numeric function did not work on the character vector. There is
not logical way to convert random words without a pattern into
    numbers.

## Second Code Chunk: Convert and multiply

``` r
as.numeric(pull(prob1_df, prob1_logic_vec))*pull(prob1_df, prob1_sample)
```

    ## [1] 0.000000 0.000000 0.000000 2.235050 0.000000 0.000000 0.000000 1.185998

``` r
as.factor(pull(prob1_df, prob1_logic_vec))*pull(prob1_df, prob1_sample)
```

    ## Warning in Ops.factor(as.factor(pull(prob1_df, prob1_logic_vec)),
    ## pull(prob1_df, : '*' not meaningful for factors

    ## [1] NA NA NA NA NA NA NA NA

``` r
as.numeric(as.factor(pull(prob1_df, prob1_logic_vec)))*pull(prob1_df, prob1_sample)
```

    ## [1] -0.22764070 -2.27187197 -1.24547077  4.47010045 -0.18481126 -0.43334521
    ## [7] -0.05185446  2.37199682

As seen above, we were able to convert the logical vector into a numeric
value and multiply by the random sample.The other two commands had more
surprising results. We learned that converting the logical vector to a
factor vector resulted in a vector that was unable to be multiplied by
the random sample. Then, we were able to convert a logical vector into a
factor vector and then into a numeric vector, which was able to be
multiplied. Both these results align with our previous attempts to do
math with different data types: (1) we tried to take the mean of a
factor and that didnt’ work and (2) we convereted a factor vector into a
numeric vector and were able to take the mean.

# Problem 2

``` r
prob2_df = tibble(
  x = rnorm(500, mean = 0, sd = 1),
  y = rnorm(500, mean = 0, sd = 1),
  prob2_logic_vec = (x + y) > 1,
  prob2_num_vec = as.numeric(prob2_logic_vec),
  prob2_factor_vec = as.factor(prob2_logic_vec)
)
```

## Describing the newly created data frame

  - This dataset contains 500 rows and 5 columns

  - The mean of x is 0.0078396

  - The median of x is -0.0164342

  - The standard deviation of x is 1.0242121

  - The proportion of cases for which x + y \> 1 is
0.246

## Plots for Problem 2

``` r
plot1 = ggplot(prob2_df, aes(x = x, y = y, color = prob2_logic_vec)) + geom_point()
plot1
```

![](p8105_hw1_hf2379_files/figure-gfm/problem2_plot_logical-1.png)<!-- -->

  - This plot has two colors, red and blue, because we set the colors to
    equal the logical vector which was two outcomes: FALSE and
TRUE.

<!-- end list -->

``` r
plot2 = ggplot(prob2_df, aes(x = x, y = y, color = prob2_num_vec)) + geom_point()
plot2
```

![](p8105_hw1_hf2379_files/figure-gfm/problem2_plot_nvector-1.png)<!-- -->

  - This plot’s colors range from light blue (1.0) to dark blue (0.0)
    because we set the color equal to the numeric vector which was
    outcomes 0 and 1. This numeric vector was created from the logical
    vector (TRUE=1 and FALSE=0). While the color legend provides a range
    of colors from 0-1, the output only shows dots that correspond to 0
    and 1 identical to plot 1
above.

<!-- end list -->

``` r
plot3 = ggplot(prob2_df, aes(x = x, y = y, color = prob2_factor_vec)) + geom_point()
plot3
```

![](p8105_hw1_hf2379_files/figure-gfm/problem2_plot_fvector-1.png)<!-- -->

  - This plot has two colors, red and blue, because we set the colors
    equal to the factor vector which was two outcomes: FALSE and TRUE.
    This factor vector was created from the logical vector and therefore
    the graph is identical to plot 1.

## Saving my scatterplots

``` r
ggsave(plot1, file = "plot1.png")
```

    ## Saving 7 x 5 in image

``` r
ggsave(plot2, file = "plot2.png")
```

    ## Saving 7 x 5 in image

``` r
ggsave(plot3, file = "plot3.png")
```

    ## Saving 7 x 5 in image

Done with HW 1\!
